#Translates indexes between a singular integer value and a tuple representing an index into a multi-dimensional array
class IndexTranslator(object):
    def __init__(self, dims):
        self._dims = dims

        self._multipliers = [1]
        multiplier = 1
        for mi in range(1,len(dims)):
            multiplier = multiplier * self._dims[mi-1]
            self._multipliers.append(multiplier)

    #Returns the singular index based on a multi-dimensional index tuple
    def from_indexes(self, *indexes):
        acc = 0
        for i in range(len(self._dims)):
            if indexes[i] >= self._dims[i]:
                raise IndexError("Index out of bounds, check dims")
            index = indexes[i]
            acc += index*self._multipliers[i]

        return acc

    #Returns a multi-dimensional index tuple from a singular index
    def to_indexes(self, i):
        indexes = []

        acc = 0
        for t in range(len(self._dims)-1):
            r = (i-acc)%self._multipliers[t+1]
            acc += r

            indexes.append(r/self._multipliers[t])

        indexes.append((i-acc)/self._multipliers[-1])

        return indexes

    #Returns the highest integer index that can be generated by this translator 
    def max(self):
        acc = 1
        for t in range(len(self._dims)):
            d = self._dims[t]
            acc = acc * d
        return acc

#Container object implementing a run-time defined N-dimensional array 
class NDimArray(object):
    def __init__(self, dims, items=[]):
        self._it = IndexTranslator(dims)
        self._data = [None for i in range(self._it.max())]

        for item in items:
            self.add(item)

    def add(self, item):
        indexes = item[:-1]
        value = item[-1]

        i = self._it.from_indexes(*indexes)
        self._data[i] = value

    def __getitem__(self, indexes):
        if isinstance(indexes, list) or isinstance(indexes, tuple):
            if len(indexes) != len(self._it._dims):
                raise KeyError(indexes) 

            i = self._it.from_indexes(*indexes)
            return self._data[i]
        else:
            #Indexes is an integer value and we look up the row
            return self._data[indexes]

    def reduce(self, target_indexes):
        subset = []

        for i, value in enumerate(self._data):
            if value is None:
                continue 

            indexes = self._it.to_indexes(i)
            match = True
            new_indexes = []
            for j in range(len(indexes)):
                if target_indexes[j] is None:
                    new_indexes.append(indexes[j])
                elif target_indexes[j] != indexes[j]:
                    match = False

            if match:
                item = new_indexes
                item.append(value)
                subset.append(item)

        new_dim = []
        for j in range(len(target_indexes)):
            if target_indexes[j] is None:
                new_dim.append(self._it._dims[j])

        return self.__class__(new_dim, items=subset)

    def __repr__(self):
        o = ""
        for i in range(len(self._data)):
            o += str(i) + " " + str(self._data[i]) + "\n"
        return o

    def get_2d_array(self, fill=None, filter_=None):
        assert len(self._it._dims) == 2, "Cannot return 2d array for %sd structure, reduce first"%len(self._it._dims)

        array = []
        for x in range(self._it._dims[0]):
            t = []
            for y in range(self._it._dims[1]):
                value = self[x,y]

                if value is None:
                    t.append(fill)
                else:
                    if filter_ is not None:
                        value = filter_(value)
                    t.append(value)
            array.append(t)

        return array

    def get_labels(self):
        return self._labels

    def get_valid_count(self):
        count = 0

        for v in SequentialIterator(self):
            if v is not None:
                count += 1

        return count


    def __len__(self):
        return self._it.max()

class LabeledNDimArray(NDimArray):
    def __init__(self, dims, items, labels = [],  auto_populate_labels=False):
        super(LabeledNDimArray, self).__init__(dims, items)

        if auto_populate_labels:
            for item in items:
                if item is not None:
                    labels = item[-1].characteristics.keys()
                    break

        self._labels = labels

    def reduce(self, target_indexes):
        new_array = super(LabeledNDimArray, self).reduce(target_indexes)

        new_labels = []
        for j in range(len(target_indexes)):
            if target_indexes[j] is None:
                new_labels.append(self._labels[j])

        new_array._labels = new_labels

        return new_array


class SequentialIterator(object):
    def __init__(self, ndimarray):
        self._array = ndimarray
        self._current_index = 0

    def __iter__(self):
        self._current_index = 0
        
        return self
        
    def next(self):
        if self._current_index+1 >= len(self._array):
            raise StopIteration
        
        self._current_index += 1
        
        return self._array[self._current_index]
